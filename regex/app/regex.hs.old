import Options.Applicative


-- Define a tree for regex
data RegexTree = Empty                -- Represents the empty set
               | Epsilon              -- Represents the empty string
               | Literal Char         -- Represents any literal character
               | Concat RegexTree RegexTree
               | Union RegexTree RegexTree
               | Star RegexTree
               deriving (Show, Eq)


-- Command-line options data type
data Options = NoOp 
  deriving (Show)

-- Parser for command-line options
optionsParser :: Parser Options
optionsParser =
  flag' NoOp
    ( long "no-op"
    <> help "Perform no operation on the regex (just parse and print)" )
  -- <|> will be used to separate different options


-- Process a regex string to build a parse tree
buildTree :: String -> RegexTree
buildTree input = head (foldl processChar [] input)
  where
    processChar :: [RegexTree] -> Char -> [RegexTree]
    processChar stack char
      | char == '*' =
          case stack of
            (t:ts) -> 
              -- We need to check for the special case that we read "/*"

              if t == Empty then  -- "If the top of the stack is "/""
                Epsilon : ts      -- Pop the t off by adding epsilon to the tail.

              else                -- t is anything but "/"
                (Star t) : ts     -- Otherwise, just put the star on as normal
            []     -> error "Invalid regex: '*' requires one operand"

      | char == '.' =
          case stack of
            (t2:t1:ts) -> (Concat t1 t2) : ts
            _          -> error "Invalid regex: '.' requires two operands"

      | char == '+' =
          case stack of
            (t2:t1:ts) -> (Union t1 t2) : ts
            _          -> error "Invalid regex: '+' requires two operands"

      | char == '/' = Empty : stack -- Push the empty set onto the stack

      | otherwise = (Literal char) : stack


-- Main
main :: IO ()
main = do

  -- Parse command-line options
  opts <- execParser optsInfo

  -- Read input from stdin until EOF
  input <- getContents

  -- Split the input into lines (while filtering out empty lines)
  -- '.' is the composition funciton, it is used because not expects a bool, but null is a function
  -- so (not null) wouldn't work.
  let linesOfInput = filter (not . null) (lines input)

  -- Build a tree for each line and print the result
  let trees = map buildTree linesOfInput

  case opts of
    NoOp -> mapM_ print trees


optsInfo :: ParserInfo Options
optsInfo = info (optionsParser <**> helper)
  ( fullDesc
    <> progDesc "Parse and process regexes from stdin"
    <> header "regex - a simple regex parser"
  )